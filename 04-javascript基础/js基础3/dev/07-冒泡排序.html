<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 冒泡排序
        // 比较相邻的元素。 如果第一个比第二个大， 就交换他们两个。
        // 对每一对相邻元素作同样的工作， 从开始第一对到结尾的最后一对。 在这一点， 最后的元素应该会是最大的数。
        // 针对所有的元素重复以上的步骤， 除了最后一个。
        // 持续每次对越来越少的元素重复上面的步骤， 直到没有任何一对数字需要比较。
        // 之所以叫冒泡排序， 每一轮两两比较之后， 都会冒出一个本轮最大的数， 将其移动到本轮尾部。

        var arr = [41, 32, 1, 40, 12, 5];
        // 1  n
        // 2  n-1
        // 3  n-2
        // ... 
        // n-2  2
        // n-1  1


        // 时间复杂度
        // 1一直加到 n  === n(n+1)/2


        // 经过这样一轮 比较  ,找出了一个最大值
        // for (var i = 0; i < arr.length - 1; i++) {
        //     // arr[i]和 arr[i+1]]
        //     if (arr[i] > arr[i + 1]) {
        //         // 交换位置
        //         // arr[i] = arr[i + 1];
        //         // arr[i + 1] = arr[i];
        //         var temp = arr[i];
        //         arr[i] = arr[i + 1];
        //         arr[i + 1] = temp;
        //     } // console.log(arr);
        // }
        // 需要让以上 代码 执行 5次  才能排序完成
        for (var j = 0; j < arr.length - 1; j++) {
            // 外层循环 控制轮次,arr.length-1次

            // 每执行完一趟之后,内层循环都可以少比较一次
            for (var i = 0; i < arr.length - 1 - j; i++) {
                // arr[i]和 arr[i+1]]
                if (arr[i] > arr[i + 1]) {
                    // 交换位置
                    // arr[i] = arr[i + 1];
                    // arr[i + 1] = arr[i];
                    var temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                }
            }
            // console.log(arr);
        }
        console.log(arr);
    </script>
</body>

</html>