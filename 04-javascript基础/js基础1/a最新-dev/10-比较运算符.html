<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // > < >=  <=  ==(等于)  !=(不等于)   
        // 通过比较运算符可以比较两个值之间的大小关系，
        // 如果关系成立它会返回 true，
        // 如果关系不成立则返回 false。 

        // === 严格等于  !== (严格不等于)
        // 规则 
        // 1. 对于非数值进行比较时，会将其转换为数字然后再比较。
        console.log(1 > true); // 不成立   false
        console.log(1 >= true); // 成立  true
        console.log(1 > "0"); // 成立  true

        //任何值和NaN做任何比较都是false

        console.log(10 <= "hello"); // 10<=NaN   false
        console.log(true > false); // 1>0 成立  true


        // 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较。
        // 比较两个字符串时，比较的是字符串的Unicode 编码。【非常重要，这里是个大坑】
        // 比较字符编码时，是一位一位进行比较。如果两位一样，则比较下一位，所以借用它可以来对英文进行排序。
        console.log('56' > '123'); //true  53> 49

        // 因此：当我们在比较两个字符串型的数字时，一定一定要先转型，


        // 重点   == 
        // ==这个符号，还可以验证字符串是否相同。例如：
        console.log('你好' == '你好'); // true

        // ==这个符号并不严谨，会将不同类型的东西，转为相同类型进行比较（大部分情况下，都是转换为数字）。
        console.log('100' == 100); // true

        // undefined 衍生自 null，所以这两个值做相等判断时，会返回 true。
        console.log(undefined == null); // true

        // NaN 不和任何值相等，包括他本身。
        console.log(NaN == NaN); // false

        // != 不等于   == 等于的 反面



        // 严格等于 === 
        // 会先检测数据类型,数据类型不一致,直接false
        console.log('100' === 100); // 不相等  false
        // !==  是 ===  的  反面
    </script>
</body>

</html>