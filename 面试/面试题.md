
## bfc
- BFC是一个独立的独立容器，不受外界干扰或干扰外界
- 计算BFC高度的时候，浮动元素也会参与计算
- BFC的区域不会与浮动元素的区域重叠
- BFC垂直方向边距重叠
bfc 渲染规则
 - flot 
 -  overflow不为默认值
 - posttion 为abslout,fiexd
 - dsplay 为inine-lock
## 闭包
当父级函数被销毁时 返回的子函数仍然保留 父级的变量和作用域链,因此可以继续调用父级的变量对象,这样的函数被称为闭包
+  闭包的第一个用途就是我们在函数外部能访问到函数内部的变量.通过使用闭包,我们可以通过外部调用闭包函数,从而在外部访问到函数内部的变量,可以用这种方法来创建私有变量
+  函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留存在内存中,因为闭包函数中保留这个变量对象的引用,所以这个把变量对象不会被回收
## 作用域
作用域是定义变量的区域,他有自己的一套访问规则,这套规则来管理浏览器引擎如何在当前作用域中以及嵌套的作用域中根据变量进行查找
- 作用域连
## es6 中的新特性
- 默认参数
- 模版表达式
- 多行字符串
- 拆包表达式
- 改进的对象表达式
- 箭头函数 =&>
- Promise
- 块级作用域的let和const
- 类
- 模块化

## 原型
1. 在js中 每当定义一个函数数据类型时 都会天生自带一个显示原型 prototype属性,
2. 这个属性是一个对象值, 浏览器会默认给他开辟一个堆内存,并天生自带一个construction属	性,这个属性指向的是当前函数本身,
3. 每一个对象又有一个__proto__指向当前实例所属的prototype

## promise三种状态回调
+ peeding
+ rejection
+ resolve

## Promise.all
1. 是将多个promise 包装成一个新的promise实例. 
2. 成功时返回一个结果数组
3. 失败是返回最先reject的值

## Vue 组件 data 为什么必须是函数 ?

1. 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。
2. 所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。
3. 为了避免多个组件实例公用同一份数据,
4. 组件复用的时候都会有自己独一份的data 每一份的data都是独立的

## mvvm mvc
1. mvc 所有的通讯都是单项的 提交一次反馈一次,通讯一次 相互制约形成闭环
+ 视图(view) : 用户界面 (传送指令到controller)
+ 控制器(controller) : 业务逻辑 (完成业务逻辑后 要求model 改变状态)
+ 模型(model):保存数据(将新的数据发送到view 用户得到反馈)
2. mvvm 各部分之间的通讯都是双向的
数据的更改会改变视图 试图更改也会改变数据
view 与 model 不发生联系 都是通过viewmodel 传递

## 任务队列
1. JS 属于单线程
+ 任务队列
- 同步任务
- 同步任务是在主线程上执行的任务,只有前一个任务执行结束,才能执行下一个任务
+ 异步任务
- 异步任务不能进入主线程,而是进入"任务队列" 只有"任务队列"通知主线程某个异步任务可以执行了，该任务才会进入主线程执行。

## 如何理解nextTick
-  nextTick(),是将回调函数延迟到下一次dom更新后调用
-  简单理解就是 当数据更新了 在dom中渲染后, 自动执行该函数

## vuex存储和本地存储(localstorage、sessionstorage,cookie)的区别
- vuex 存储在内存, 
1. vuex 用于组件之间的传递
- localstorage 则以文本的方式永久存储
1. localstorage用于页面之间的传值
2. localstorage 存储 5m
3. 只要不手动删除就会一直存在 
- sessionstorage 临时存储页面关闭时消失
1. sessionstorage存储 5m或更多
- cookie 所有窗口都是共享的
1. 用于在服务器中传递信息
2. 这个cookie 不能超过4k

## typeof 能判断哪些
+ 能是识别所有值类型
+ 识别函数类型
+ 引用数据类型,
+ null 是一个特殊引用类型 指向为空地址

## 手写深拷贝
```javascript
const obj = {
age: 20,
name: '123',
address: {
city: 'beijing',
},
arr: ['1', '2']
}

function copayer(obj = {}) {
if (typeof obj != 'object' || obj == null) {
return obj;
}
let newobj
if (obj instanceof Array) {
newobj = []
}else {
newobj = {}
}
for (let key in obj){
if (obj.hasOwnProperty(key)){
newobj[key] = copayer(obj[key])
}
}
return newobj;
}
```
## new 一个函数的时候发生了什么
1. 创建了一个空对象
2. 让构造函数中的this指向新对象，并执行构造函数的函数体
3. 设置新对象的proto属性指向构造函数的原型对象
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象
## diff算法
diff算法的作用就是在patch子vnode过程中,找到与新vnode 对应的老vnode,复用真实的dom节点
避免不必要的性能开销
## Instansof 原理
能够在实例的原型对象中找到该构造函数的Protoptype属性是否指向原型对象 
## js事件循环
1. 首先js 是单线程运行,在代码执行的时候,通过将不同函数的执行上下文压入执行站中来保证代码的执行
2. 在执行同步代码的时候如果遇到异步事件,js引擎并不会一直等待结果 而是将这个事件挂起继续执行 执行站中的任务
3. 当同步事件执行完毕后,在将异步事件对应的回调函数加入到当前执行栈中.
4. 任务队列也可以分为微任务队列和宏任务队列, 当当前执行栈中的事件执行完毕后,js引擎会首先判断微任务队列中 是否有任务可以执行,如果有 就会先把微任务压入执行栈中
5. 当微任务队列中的任务都执行完毕后在去判断宏任务队列中的任务.
## arguments 的对象是什么？
arguments 对象是函数中传递的参数值的集合
## 何时使用 === 何时使用 == 
除了null 之外,都使用 ===

# 浏览器

## 回流和重绘
### 浏览器渲染
1. 解析HTML，生成DOM树，
2. 解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上
+ 回流
- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器尺寸发生变化时
- 重绘
- css颜色样式发生改变时
## v8 垃圾回收
将内存中不在使用的数据进行清理,释放出内存空间,v8将内存分为新生代空间 和老生带空间
## 内存泄漏
- 意外外的全局变量无法被收回
- 定时器: 未正确的关闭 导致所引用的内部变量无法被释放
- 事件监听: 没有正确销毁
- 闭包 :会导致父级中的变量无法释放
- dom 引用: dom 元素被删除时, 内存中的引用违背正确清空

# 服务端与网络

## url到浏览器解析的过程 
1. 解析域名为ip
2. 根据ip链接到服务器
3. 建立tcp链接发送http请求
4. 服务器响应http请求 发送html代码资源
5. 解析资源html
6. 浏览器渲染html
7. 服务器响应关闭tcp请求

## http 和 https的区别
1. https需要到证书颁发机构申请证书,
2. http是超文本传输协议 明文传输, https是具有安全性的ssl加密传输协议
3. http和https使用的是完全不同的链接方式,使用的端口也不一样 前者是80 后者是433
4. http链接简单是无状态的
5. https协议是有ssl+http协议构建的可以加密传输,

## 常见状态码
- 1xx: 接受，继续处理
- 200: 成功，并返回数据
- 201: 已创建
- 202: 已接受
- 203: 成为，但未授权
- 204: 成功，无内容
- 205: 成功，重置内容
- 206: 成功，部分内容
- 301: 永久移动，重定向
- 302: 临时移动，可使用原有URI
- 304: 资源未修改，可使用缓存
- 305: 需代理访问
- 400: 请求语法错误
- 401: 要求身份认证
- 403: 拒绝请求
- 404: 资源不存在
- 500: 服务器错误
## get /post
 - get 有缓存,请求长度受限,会被历史保存,多用于请求数据
 - post 安全,数据量大,更多编码类型

## 安全问题
- XSS攻击: 注入恶意代码
cookie 设置 httpOnly
转义页面上的输入内容和输出内容
-  CSRF: 跨站请求伪造，防护:
get 不修改数据
不被第三方网站访问到用户的 cookie
设置白名单，不被第三方网站请求
请求校验
# vue

## vue中的声明周期
- 从 Vue 实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！
- befocreate 创建前  (刚从内存中创建出来 此时还没有data,和methos)
- create 创建后 (已经从内存中创建出来,此时已经有了data和methos)
- beforeMounted 加载前 (此时已经完成了模板编译 但是还没有挂载到页面)
- Mounted 加载后 (此时已经将编译好的模板挂载到了指定容器中显示了)
- beforeUpdate 更新前 (状态更新前执行,此时data中的值是最新的值,但是页面上的数据还是旧的,因为此时还没有刷新dom)
- update 更新后(实例已经更新完毕之后调用此函数,此时data上的状态和页面上的数据都已经更新完成)
- beforeDestroy 实例销毁前(实例销毁前调用 ,在这一步实例仍然可用)
- destroy 销毁后(vue实例销毁后调用)
## Vue中computed和watch的区别
- 计算属性:
1. 支持缓存,只有当依赖发生改变时,才会重新计算
2. 不支持异步,当computed内有异步操作时无效,无法监听
3. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed 
- 监听属性:
1. 不支持缓存,数据变 则相应的触发操作
2. watch 支持异步操作
3. 监听的函数必须有两个参数 第一个参数是最新的值 第二个参数是输入之前的值
4. 当一个属性发生变化时,需要执行对应的操作 一对多;

## vue 响应式原理
- objcet.defineProperty 重新定义data中的属性, objcet.defineProperty 可以使获取的数据于设置增加一个拦截功能,拦截属性的获取,进行依赖收集,当拦截到属性的更新操作时,进行通知
![avatar](https://pic2.zhimg.com/80/v2-b94d747fd273ec8224e6349f701430fd_1440w.jpg)
- 具体方法为: 首先vue使用 initdata 初始化用户传入的参数, 然后使用 new Oberver 对数据进行观测 如果数据是一个对象类型 就会调用 this.walk 对对象进行处理, 内部使用 defineereactive 循环对象属性定义响应式变化, 核心就是使用object.defineProperty 重新定义数据
![avatar](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5a919f243644a3a0fbeaa884d2f9cd~tplv-k3u1fbpfcp-watermark.image)

## vue 如何实现对数组的变化
- 使用函数劫持的方式，重写了数组的方法
-  Vue将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新。如果数组中包含引用类型，会对数组中的引用类型再次进行监控。
## nextTick
在下次dom 更新循环结束后执行延迟回调, 可用于获取更新后的dom 状态

## vue-router
- mode
 hash
 history
- 跳转

	this.$router.push()
	<router-link to=""></router-link>
- 占位

	<router-view></router-view>

## vuex
 - state : 状态中心
 - mutatios: 更改状态
 - actions: 异步更改状态
 - getters:获取状态
 - modules : 将state 分成多个modules 便于管理 

##  盒子模型
 -  标准盒子模型：宽度=内容的宽度（content）+ border + padding
 -  低版本IE盒子模型：宽度=内容宽度（content+border+padding)

## 强缓存 协商缓存

 浏览器分为强缓存和协商缓存
 ,强缓存就是看返回的herader 中有没有缓存标识,有的话就从本地缓存中取出,如果没有就走协商缓存,通过服务器来确定是否更新数据,如果资源没有发生改变就从本地取出

## 跨域
- JOSNP: 利用<script> 标签不收跨域限制的特点, 缺点是只能支持get请求
- 设置 cors:access-control-allow-origin: *
- postMessage
- 

